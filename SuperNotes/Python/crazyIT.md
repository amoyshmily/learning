# 一、简介

#### 定义
```
Python是一种面向对象、解释型、弱类型的脚本语言。
```


# 二、变量

#### 注释
解释程序某些部分的作用和功能，给人看的。
> 单行注释
```
# 单行注释以#号开头
```

> 多行注释
```
'''
多行注释就是一次性将程序中
的多行代码注释掉
'''

"""
可以用三个单引号，也可以
使用三个双引号。
"""
```


#### 变量

> 释义
```
变量就像一个小容器，用来存放程序中的数据。
python中的变量特点：直接赋值、动态改变。
```


> 变量VS常量
```
常量一旦保存某个数据后，该数据不能发生改变。变量保存的数据则可以多次发生改变。
```

> 赋值
```
使用=号进行变量赋值。例如 a = 1, msg="Hello world!"
```

> 命名规则
```
python需要使用标识符给变量命名。规则：
1.必须以字母、下划线开头，后面可以跟任意数目的字母、文字、数字和下划线。
2.区分大小写
3.不能使用关键字，如type,None,pass,with等
```


# 三、数据类型（6种）

```
Python3 的六个标准数据类型中：
不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；
可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。


【序列Sequence】
一种包含多项数据的数据结构，序列的元素按照顺序排列，并且可以通过索引进行访问。常见的
序列有字符串、元祖、列表等。

# 序列封包
程序将多个值，赋值给一个变量时，Python会自动将多个值封装成元祖。
注意：封包后的变量的数据类型一定是元祖。
num = 10, 20, 30
print(type(num))    # <class 'tuple'>


# 序列解包
程序将序列（元祖/列表）直接赋值给多个变量，此时序列的各个元素就会被一次赋值给每个变量。要求序列的
元素个数与变量个数完全相同。
tup = (10, 20, 30)      # 解包支持分解元祖
a, b, c = tup  
print(c)    # 30

li = ['a', 'b', 'c']    # 解包支持分解列表
x, y, z = li
print(y)

# 利用封包和解包机制进行批量赋值
x, y, z = 1, 2, 3
过程等同于：
my_tup = 1, 2, 3    # (1, 2, 3)
x, y, z = my_tup    # x=1,y=2,z=3


# 部分解包
在序列解包时，也可以只解出部分元素，包内剩下的元素当做一个整体列表保存。具体做法是在
变量之前添加星号*，则代表该变量时一个列表，就能保存多个元素。
注意：部分解包后的整体变量部分的数据类型一定是列表。
tup = (1, 2, 3, 4, 5, 6, 7, 8)
x, y, *z = tup
print(x)    # 1
print(y)    # 2
print(z)    # [3, 4, 5, 6, 7, 8]

li = ['I', 'l', 'o', 'v', 'e', 'U']
a, *b, c = li
print(a)    # I
print(b)    # ['l', 'o', 'v', 'e']
print(c)    # U


【区间range】
```

## 3.1 Number 数字

```
Python3 支持 int、float、bool、complex（复数）。
```


#### 整型 int


> 整型的4种表示形式
```
1.十进制形式：如0~9
2.二进制形式：以0b或0B开头的整数。
3.八进制形式：以0o或0O开头的整数。
4.十六进制形式：以0x或0X开头的整数（其中10~15分别以a~f表示，不区分大小写）
```

> 分隔符
```
Python 3.X 允许为了提高可读性，允许给数值(包括浮点数)增加下划线作为分隔符，不会影响数值本身。
例如：million = 1_000_000
```


#### 浮点型 float

用于保存带小数的数值。


> 浮点数的2种表示形式
```
1.十进制形式：例如3.14
2.科学计数法：如5.12e2等同于5.12×10²。
```


#### 布尔型 bool
```
True/False

```


#### 复数 complex
```
太过深奥，略过
```


## 3.2 String 字符串

> 定义
```
使用单引号或者双引号包围的一串字符。

例如：'hello'和"I'm fine"都是字符串。
```

> 转义
```
Python中使用反斜杠\将字符串中的特殊字符进行转义。
例如：msg = 'I\'m a student'

还可以转义换行符。
例如：
worlds = 'There are so many \
    stories that I want to \
    share with you.
    '
    
常见的转义字符：
\b表示：退格符
\n表示：换行符
\r表示：回车符
\t表示：制表符
\"表示：双引号
\'表示：单引号
\\表示：反斜杠


```

> 原始字符串
```
由于反斜杠\自身拥有特殊意义，一旦字符串中必须使用\时，必须对其进行转义。

例如Windows系统的路径C:\windows\System32，转义后的普通写法是：path = 'C:\\windows\\System32'。
但是这种处理方式显得非常繁琐。

原始字符串以r开头，原始字符串不会把反斜杠当成特殊字符。
上述路径可以写为 path = r'C:\\windows\\System32'

```

> 拼接
```
1. 字符串和字符串拼接
Python3允许使用加号+作为字符串之间的拼接运算符。
msg = 'hello' + 'world'
print(msg)

2. 字符串和数值拼接
Python3不允许直接拼接字符串和数值，必须将数值转换成字符串后才可以执行拼接操作。可以通过str()
或者repr()函数来将数值转成字符串。
s = 'my score is '
n = 100
msg1 = s + str(n)
msg2 = s + repr(n)
```

> 长字符串
```
如果将多行注释形式的内容赋值给变量，那么就是一个长字符串，并且不会被解释器忽略。多行文本中
记得及时添加转义符\对换行符进行转义。

例如：
worlds = 'There are so many \
    stories that I want to \
    share with you.
    '
```

> 格式化
```
1. 占位符 %

转换说明符：
d,i：    转换为带符号的十进制形式的整数
o：      转换为带符号的八进制形式的整数
x,X：    转换为带符号的十六进制形式的整数
e,E：    转化为科学计数法表示的浮点数
f,F：    转化为十进制形式的浮点数
g：      智能选择使用f或者e格式
G：      智能选择使用F或者E格式
C：      转换为单字符（只接受整数或单字符字符串）
r：      使用repr()将变量或表达式转换为字符串
s：      使用str()将变量转换为字符串

宽度：在占位符中添加数字n可以指定转换后的最小宽度为n。默认对齐方式是右对齐，默认左侧补位方式是空格。
例如：'%6d' % 10 表示 “    10”

标志：
-：指定转换结果的对齐方式为左对齐，指定后左侧补位失效。
+：表示数值一定带着符号（正数带正号“+”，负数带负号“-”）
0：表示数值的补位方式是0，仅对左侧有效。

示例：
num = 99
s1 = '得分: %06d 分' % num # 最小宽度6，补位0
s2 = '得分: %+06d 分' % num # 最小宽度6，显示正负号，补位0
s3 = '得分: %-6d 分' % num # 最小宽度6，左对齐
s4 = '我%-6s你' % '爱'

>>>
得分: 000099 分
得分: +00099 分
得分: 99     分
我爱     你

精度：
对于转换浮点数，允许指定小数点后的数字位数。如果转换的是字符串，则允许指定换换后最大的字符数。这个
标志称为精度值。精度标志被放置在最小宽度之后，中间用点号.隔开。

value = 3.1415926
s1 = '最小宽度8，保留3位小数：%8.2f' % value
s2 = '最小宽度6，只保留3个字符：%6.3s' % '我爱你Python'

>>>
最小宽度8，保留3位小数：    3.14
最小宽度6，只保留3个字符：   我爱你

# 使用字典来批量格式化
msg = '姓名：%(name)s , 年龄：%(age)d , 体重：%(weight).1f 公斤'
cifer = {'age': 18, 'name': 'cifer', 'weight': 66.5}
print(msg % cifer)  # 姓名：cifer , 年龄：18 , 体重：66.5 公斤


2. 函数 format()
```


> 操作
```
1.索引
字符串本质上就是由多个字符组成，因此可以通过索引来操作字符串。字符串直接在方括号[]中
使用一个索引即可获得对应的单个字符，格式为s[m]。

索引支持正序和逆序。正序时索引值为正数，从0开始；逆序时索引值为负数，从-1开始。


2.切片
在方括号中使用两个索引来获取字符串中的一段字符，格式为s[m:n]。其中n要大于m，否则获取为空字符。
s = 'hello world'
s1 = s[2:6]     # llo 
s2 = s[-3:-1]   # rl



切片时允许省略起始索引或结束索引。如果省略起始索引，默认起始位置为字符串的开头；
如果省略结束索引，默认结束位置为字符串的结尾。
s = 'hello world'

s1 = s[2:]  # llo world
s2 = s[:-2] # hello wor
s3 = s[:]   # hello world


3.成员检测
支持使用in运算符判断字符串是否包含某个字符或者子串。
s = 'hello world'

flag1 = 'x' in s        # False
flag2 = 'hello' in s    # True


4.长度
使用Python内置函数len()获取字符串长度。
s = 'hello world'
l = len(s)      # 11

5.极值
使用Python内置函数max()和min()函数即可获取字符串中的最大字符和最小字符。

s1 = 'hello world'
s2 = '1234'

print(max(s1))  # w
print(max(s2))  # 4

6.大小写
title():将每个单词的首字母转成大写，其他字母不变。
upper():将整个字符串转成大写。
lower():将整个字符串改成小写。

s = 'hello world WOW'

print(s.title())    # Hello World Wow
print(s.upper())    # HELLO WORLD WOW
print(s.lower())    # hello world wow

7.删除空白
strip():返回删除字符串前后空白的新字符串。
lstrip():返回删除字符串左侧空白之后的新字符串。
rstrip():返回删除字符串右侧空白之后的新字符串。


8.查找
startswith():判断字符串是否以指定的子串开头。
endswith():判断字符串是否以指定的子串结尾。
find():查找指定子串在字符串中出现的位置索引。如果没有找到子串，则返回-1。
index():查找指定子串在字符串中出现的位置索引。如果没有找到子串，则引发ValueError错误。

9.替换
replace():使用指定子串来替换字符串中指定字符。
translate():使用指定的翻译映射表对字符串执行替换。

注意：翻译映射表不能直接使用字符本身，必须使用字符的编码。
maketrans():快速创建翻译映射表。
table = str.maketrans('hel', '123')
print(table)    # {97: 49, 98: 50, 99: 51}

s = 'hello world'
print(s.translate(table))   # 1233o wor3d

10.分割
split():将字符串按照指定的分割符进行分割，返回成多个子串组成的列表。

示例：
s = 'hello,world'
li = s.split(',')   # ['hello', 'world']

11.拼接
join():使用连接符，将迭代对象中的字符串拼接成一个字符串。

示例：
s1 = ','.join('hello')  # h,e,l,l,o

s2 = ','.join(['hello', 'world'])   # hello,world
``` 



## 3.3 Tuple 元祖 ()

> 定义
```
有序，允许重复，元素不可变。元素的数据类型支持数字、字符串和序列等，支持嵌套。是序列的一种形式。
```

> 实例化
```
创建元祖时使用圆括号（小括号），并在括号中列出元祖的元素。元素之间用英文逗号隔开。
t1 = (1,)      # <class 'tuple'>
注意：哪怕只有一个元素的元祖也必须加上逗号。

t2 = (1, 1, 2, 'Hello World')   # <class 'tuple'>

# 封包
t3 = 1, 2, 3    # 利用封包机制    <class 'tuple'>

# 嵌套
t4 = (1, 1, 2, (3, 2, 1), 'Hi')  # <class 'tuple'>

# 转换函数
li = [1, 2, 3]
t5 = tuple(li)  # (1, 2, 3)

t6 = tuple(range(0, 10))    # (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)


反例：
t0 = (1)    # 这种写法跟t2 = 1 是一样的效果。
print(type(t0)) # <class 'int'>
```

> 访问
```
（1） 访问单个元素
语法：[index]，返回元素值。

元祖可以通过索引来访问元素。索引值默认从0开始，第一个元素的索引值是2，以此类推；索引支持
负数，倒数第一个元素的索引值为-1，倒数第二个元素的索引值是-2，以此类推。

元祖的元素相当于常量，只能使用它的值，不能对它重新赋值。

my_tuple = (0,99,'hello', 'world')
print(my_tuple[1])      # 99
print(my_tuple[-1])     # world


（2） 访问多个元素：切片
完整语法：[start:end:step]，返回一个元祖。

语法中的start和end两个索引值都可以使用正数或者负数，表示收集从start索引的元素开始（包含），直到
end索引的元素结束（不包含）的所有元素。step表示步长（间隔），使用负数无意义。

my_tuple = (0, 'hello', 'world', 99, 'cifer', 'python', 'java')

tup1 = my_tuple[2:4]    # 获取索引从2到4（不含）的所有元素 ('world', 99)
tup2 = my_tuple[-4:-2]  # 获取索引从-4到-2（不含）的所有元素 (99, 'cifer')
tup3 = my_tuple[2:5:2]  # 获取索引从2到5（不含）且间隔为2的所有元素 ('world', 'cifer')

```

> 算术运算
```
（1）加法 ()+()
元祖支持加法运算，加法的和是两个元祖所包含元素的合集。

tup1 = (1,2,3)
tup2 = (3, 'hi', 'python')
tup3 = tup1+tup2    # (1, 2, 3, 3, 'hi', 'python')

（2）乘法 ()*N
元祖可以乘以倍数N（整数），意义就是把她们包含的元素重复N次。

```

> 成员检测
```
使用in运算符来判断元祖是否包含某个元素。

tup = (1, 2, 3, 3, 'hi', 'python')
flag1 = 'python' in tup     # True
flag2 = 'java' in tup      # False
```

> 统计
```
元素要求：元素必须是相同数据类型并且可以比较大小，否则会报错。支持对数字和字符串的比较。
如果比较的是字符串，则依次按照字符串中的每个字符对应的编码来比较字符串的大小。

tup1 = (1, 2, 3, 3, 99, -2)  # 元素一律为数字
tup2 = ('A', 'Hi', 'HI', 'world')   # 元素一律为字符串
tup3 = ('我', '爱', '你')
tup4 = ('我爱你'）

（1）个数 len()
num = len(tup1)  # 6

(2)最大值 max()
max1 = max(tup1)  # 99
max2 = max(tup2)    # world
max3 = max(tup3)    # 爱
max4 = max(tup4)    # 爱

（3）最小值 min()
min1 = min(tup1)  # -2
min2 = min(tup2) # A
min3 = min(tup3)    # 你
min4 = min(tup4)    # 你

```


## 3.4 List 列表 []

> 定义
```
有序，允许重复，元素可变。是序列的一种。
```

> 实例化
```
# 直接赋值
L1 = [1, 2, 3, 'Hello', (1,2,3), ['a', 'b', 'c'], '列表']

# 函数
L2 = list(range(0,10))  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

tup = (1, 2, 3)
L3 = list(tup)  # [1, 2, 3]

L4 = list(i for i in range(0, 10, 2))   # [0, 2, 4, 6, 8]

```

> 访问
```
跟元祖一样。支持索引和切片。
```

> 算术运算
```
跟元祖一样。支持加法和乘法（倍数）。
```

> 成员检测
```
跟元祖一致。使用in运算符判断是否包含。
```

> 统计
```
跟元祖一致。支持len()函数求个数,max()函数求最大值，min()函数求最小值。
```

> 增删改查
```
（1）增
append()方法：单个添加。支持传入单个值，也可以接收元祖和列表对象，会把传入的元素当做一个整体
追加到列表的最后面。

L = [1, 2, 3]
L.append(99)    # [1, 2, 3, 99]
L.append(['a', 'b', 'c'])   # [1, 2, 3, 99, ['a', 'b', 'c']]
L.append(('x', 'y'))    # [1, 2, 3, 99, ['a', 'b', 'c'], ('x', 'y')]

extend()方法：批量追加。仅支持元素集，不支持单个值。此时不会把元素集当成给一个整体，
会追加元素集中的元素。
L = [1, 2]
L.extend(range(4,7))    # [1, 2, 4, 5, 6]
L.extend(['a', 'b'])    # [1, 2, 4, 5, 6, 'a', 'b']
L.extend(('X', 'Y'))    # [1, 2, 4, 5, 6, 'a', 'b', 'X', 'Y']
L.extend({'爱江山','爱美人'})   # [1, 2, 4, 5, 6, 'a', 'b', 'X', 'Y', '爱江山', '爱美人']

insert()方法：插入。在列表的指定位置追加元素。

（2）删
del()方法：支持单个删除，也支持批量删除。

L = [1, 2, 3, 'a', 'b', 'c', '中国','废青']
del(L[-1])
print(L)    # [1, 2, 3, 'a', 'b', 'c', '中国']
del(L[2:6:2])
print(L)    # [1, 2, 'a', 'c', '中国']

remove()方法：根据元素本身来删除，并且只删除第一个找到的元素。如果需要删除的元素不存在，则会
引发ValueError错误。
L = [1, 'a', 'a', 'b']
L.remove('a')
print(L)    # [1, 'a', 'b']

clear()：删除所有全部，清空列表。
L = [1, 'a', 'a', 'b']
L.clear()
print(L)    # []

（3）改
列表的元素相当于变量，因此对其中元素的赋值即为修改元素。

（4）查
等同于访问元素。

```

> 常用方法
```
# count():统计某个元素在列表中出现的次数。

# index():获取某个元素在列表中的索引位置。
如果元素不存在，则引起ValueError错误。

# pop():末尾元素出栈，实现先入后出FILO。

# reverse():将列表元素顺序反转。

# sort():将列表元素排序。
默认从小到大排列。对于字符，则按字符串包含的字符的编码从小到大排列。
sort()支持使用关键字参数key和reverse来执行特定排序。其中key参数值为比较函数对象，reverse
参数值为布尔值，True代表反转（由大到小），False表示不反转（默认由小到大）。

L = ['Java', 'Python', 'R', 'Swift', 'Go', 'Ruby']
L.sort()    
print(L)    # ['Go', 'Java', 'Python', 'R', 'Ruby', 'Swift']
L.sort(key=len, reverse=True)
print(L)    # ['Python', 'Swift', 'Java', 'Ruby', 'Go', 'R']

```

## 3.5 Set 集合 {}
???


## 3.6 Dictionary 字典 {k:v}

> 定义
```
使用{键：值}对的形式，用于存放具有映射关系的数据。字典的key可以是任意不可变类型。
字典是无序的，key不可以重复。支持嵌套。
```

> 实例化
```
# 使用花括号创建字典
key和value之间用半角冒号隔开。当花括号中包含多个键值对时，则使用半角逗号隔开。

d = {}  # 空字典
d1 = {"name": "cifer", "age": 18}
d3 = {(20, 30):'good', 30:'bad'}    # 元祖（不可变）可以作为key，而列表不可以。


# dict()方法
可以传入包含多个key-value型列表或元祖对象的大列表来生成字典。这些子列表或元祖必须有且仅有2个元素。
d = dict()  # 空字典

li1 = [['菠菜', 2.5], ['胡萝卜', 1.6], ['空心菜', 1.2]]
d = dict(li1)   # {'菠菜': 2.5, '胡萝卜': 1.6, '空心菜': 1.2}

li2 = [('牛肉', 22.5), ('猪肉', 18.6), ('羊肉', 15.2)]
d2 = dict(li2)  # {'牛肉': 22.5, '猪肉': 18.6, '羊肉': 15.2}

# fromkeys()方法：dict类方法，使用指定的多个key创建列表，当不指定value时默认value都为None。
li = ['a', 'b', 'c']
tup = ('x', 'y')

d1 = dict.fromkeys(li)  # {'a': None, 'b': None, 'c': None}
d2 = dict.fromkeys(tup) # {'x': None, 'y': None}
d3 = dict.fromkeys(tup, 100)    # {'x': 100, 'y': 100}

# 赋值
使用方括号语法，可以为字典的key进行赋值。
d = {}
d['name'] = '中国'
print(d)    # {'name': '中国'}

```

> 增删改查

```
key是字典的关键，对字典的操作都是基于key的。通过key可以访问value，增加、修改、删除键值对，
也可以判断键值对是否存在。

# 增
如果赋值操作时key不存在，则为新增键值对。

d = {'x': 1, 'y': 2}
d['z'] = 'hello'    # {'x': 1, 'y': 2, 'z': 'hello'}

# 删
d = {'x': 1, 'y': 2}
del(d['x'])     # {'y': 2}

# 改
如果赋值操作时key已存在，则为修改该键值对的value值。
d = {'x': 1, 'y': 2}
d['x'] = 'Python'   # {'x': 'Python', 'y': 2}

# 查
即访问，可以通过方括号语法[key]来访问value。如果key不存在，则会引发KeyError错误。
d = {'x': 1, 'y': 2}
d['x']  # 1

get()方法：根据key来获取value值。当访问不存在的key则返回None，不会报错。
d = {'x': 1, 'y': 2}
print(d.get('z'))   # None

# setdefault(k, v):根据key获取对应的value。当指定的key存在时，则返回该key对应的value；
如果指定的key不存在，则返回给定的默认value。
d = {'x': 1, 'y': 2}
value1 = d.setdefault('z', 1.5)
value2 = d.setdefault('x', 1.5)
print(value1)   # 1.5
print(value2)   # 1

成员检测：判断字典是否包含某个key，可以使用in或者not in运算符。
China = {'北京': 1, '台湾': 2}
print('台湾' in China)    # True
print('伦敦' not in China)    # True
```

> 常用方法
```
# clear():清空字典的所有键值对，返回一个空字典。
d = {'name': 'Dota', 'hot': False}
d.clear()   # {}

# update():使用一个新字典来更新原有的字典。如果新字典的key已存在，则会用新字典的value覆盖
原有字典的value;如果新字典的key不存在，则向原有字典中新增。
d = {'x': 1, 'y': 2}
d1 = {'y': 99, 'Python': 60}
d.update(d1)    # {'x': 1, 'y': 99, 'Python': 60}

# items(),keys(),values():分别用于获取字典中所有的键值对dict_items对象、所有键dict_keys
对象，和所有值dict_values对象。Python不希望用户直接去操作这三个对象，但是允许通过list()函数
将他们转成列表后操作。
d = {'x': 1, 'y': 99, 'Python': 60}
items_obj = d.items()   # <class 'dict_items'>
print(list(items_obj))  # [('x', 1), ('y', 99), ('Python', 60)]

keys_obj = d.keys()     # <class 'dict_keys'>
print(list(keys_obj))   # ['x', 'y', 'Python']

# pop():通过key来删除指定的键值对。
d = {'x': 1, 'y': 2, '垃圾': '香港废青'}
d.pop('垃圾')     # {'x': 1, 'y': 2}



```

## 其他数据类型

#### 字节串 bytes

> 定义
```
bytes是不可变序列，由多个二进制的字节组成，以字节为单位进行操作。
在字节串中每个数据单元都是字节，也就是8位，其中每4位（相当于4位二进制数，最小值0，最大值15）可以
用一个十六进制数来表示，因此每个字节需要2个十六进制数表示。
```

> 格式转换
```
1.字符串str --> 字节bytes
方式一：如果字符串内容都是ASCII字符，则可以直接在字符串前加b来构建子节串。
例如：bb = b'abc123'

方式二：调用bytes构造方法，将字符串按照制定的字符集转成字节串。默认使用UTF-8字符集。
例如：bb = bytes('Python编程使我快乐！', encoding='utf-8')

方式三：调用字符串的encode()方法，将字符串按照指定字符集转成字节串。默认使用UTF-8字符集。
例如：bb = 'Python编程使我快乐！'.encode('utf-8')

2.字节bytes --> 字符串str
可以调用bytes对象的decode()方法，将字节串按照指定字符集转成字符串。
例如 bb = b'Python\xe7\xbc\x96\xe7\xa8\x8b\xe4\xbd\xbf\xe6\x88\x91\xe5\xbf\xab\xe4\xb9\x90\xef\xbc\x81'
msg = bb.decode('utf-8')
print(msg)

>>> Python编程使我快乐！
```


> 字符集

```
待补充

计算机底层并不能保存字符，因此为每个字符编号，当程序要保存字符时，实际保存的是该字符对应的编号。
当程序读取字符时，读取的也是其编号，接着去查“编号-字符对应表”（简称码表）才能得到实际的字符。

字符集：所有字符的编号组成的总和。

ASCII字符集：早期美国人只给英文字母、数字和标点符号等字符进行了编号。天真的以为这些拢共也就100多
个编号，只要1个字节（8位，支持256个字符编号）。

Unicode字符集：后来美国人又为世界上所有书面语言的字符进行了统一编号，这次他们用两个字节（16位，
支持65536个字符编号）。UTF-8和UTF-16等都属于Unicode字符集。
```

####  堆栈，队列？



# 四、运算符

#### 赋值运算符
赋值运算符为“=”，用于为变量或者常量指定值。整体被称为赋值表达式。

```
赋值表达式：
n = 1
s = 'hello world'
flag = True
s1 = s

连续赋值：赋值表达式的值就是被赋的值，因此Python支持连续赋值。
a = b = 20
print(a)    # 20,因为表达式 b=20的值为20

批量赋值：
a,b = 10,20
print(a)    # 10
print(b)    # 20
```


#### 算术运算符
7个基本算术运算符：加减乘除商余幂

> +:加法运算符
```
n = 1 + 1   # 2
```

> -:减法运算符
```
n = 2 - 1   # 1
```

> *:乘法运算符
```
n = 2 * 2   # 4
```

> /:除法运算符
```
f = 5/2     # 2.5
```

> //:求商运算符
```
f = 5 // 2  # 2
```

> %:求余运算符
```
f = 5 % 2   # 1
```

> **:求幂运算符
```
m = 2 ** 4  # 16
```


#### 比较运算符
比较运算符用于判断两个值（可以是变量、常量或者表达式）之间的大小，返回的结果是bool值。
True表示真，False表示假。
Python支持8种比较运算符。

> `>`:大于
```
判断运算符前面的值是否大于后面的值。如果大于则返回True，否则返回False。
```

> `>=`:大于或等于
```
判断运算符前面的值是否大于或等于后面的值。如果大于或等于则返回True，否则返回False。
```

> `>`:小于
```
判断运算符前面的值是否小于后面的值。如果小于则返回True，否则返回False。
```

> `>=`:小于或等于
```
判断运算符前面的值是否小于或等于后面的值。如果小于或等于则返回True，否则返回False。
```

> `==`:等于
```
判断运算符前面的值是否等于后面的值。如果相等则返回True，否则返回False。
```

> `!=`:不等于
```
判断运算符前面的值是否不等于后面的值。如果不等则返回True；否则返回False。
```

> `is`
```
判断两个变量所引用的对象是否相同。如果相同则返回True；否则返回False。
```

> `is not`
```
判断两个变量所引用的对象是否不相同。如果不相同则返回True；否则返回False。
```

注意：== 是比较两个变量的值，而is比较的是变量的引用是否指向相同的对象。
```
import time
t1 = time.ctime()
t2 = time.ctime()
print(t1 == t2)     # True
print(t1 is t2)     # False
```

#### 逻辑运算符
逻辑运算符用来操作bool类型的变量、常量或表达式，返回的结果也是bool值。
Python支持的逻辑运算符有3个：and、or、not (与、或、非)

> and
```
与。前后两个操作数必须都是True才返回True，否则返回False。

flag = 2>1 and 1>99  # False
```

> or
```
或。只要前后两个操作数中有一个是True则返回True，否则返回False。

flag = 2>1 or 1>99  # True
```

> not
```
非。对于一个操作数，如果操作数是True，则返回False；如果操作数是False，则返回True。

flag = not 1>99  # True
```


#### 索引运算符
索引运算符为“[]”。在方括号中，既可以使用单个索引值，也可以使用索引范围，并且还可以指定步长。
```
s = 'helloworld'

s1 = s[2:8]     # llowor
s2 = s[2:8:3]   # lw
s3 = s[2:8:2]   # loo

```

#### 位运算符（略）
```
我太难了
```

#### 三目运算符


#### 包含运算符


运算符优先级：
```

```


# 四、流程控制

#### if-else

#### while

#### for-in

#### 关键字
> break
> continue
> return 